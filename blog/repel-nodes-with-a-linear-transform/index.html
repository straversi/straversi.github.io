<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Repel Nodes with a Linear Transform • steven.codes</title><meta name="description" content="I got this idea for what I’ll describe as a “net of nodes”. The nodes would be anchored to points, and when a mouse moves across them, the nodes attempt to r..."><link href="https://fonts.googleapis.com/css?family=Roboto+Mono:300,400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Bitter:400,700" rel="stylesheet"> <!--<link rel="stylesheet" href="/blog/css/main.css"> --><link rel="stylesheet" href="/blog/css/main.css?v=1.3.1"><link rel="canonical" href="http://steven.codes/blog/repel-nodes-with-a-linear-transform/"><link rel="alternate" type="application/rss+xml" title="steven.codes" href="http://steven.codes/blog/feed.xml"> <script type="text/javascript" src="/blog/assets/global/jquery-2.1.1.min.js"></script> <script type="text/javascript" src="/blog/assets/global/hammer.min.js"></script> <script type="text/javascript" src="/blog/assets/global/jquery.hammer.js"></script> <script src='/blog/assets/posts/repel-nodes-with-a-linear-transform/net.js ' type="text/javascript"></script></head><body><div class="page-content"><header class="new-header"><div class="wrapper"> <a class="site-title" href="/blog/">steven.codes</a></div></header><div class="wrapper"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header class="post-header"><h1 class="post-title" itemprop="name headline">Repel Nodes with a Linear Transform</h1><p class="post-meta"> <time datetime="2016-04-19T18:47:36-07:00" itemprop="datePublished">Apr 19, 2016</time> <!-- <br>Read in about 8 minutes --></p></header><div class="post-content" itemprop="articleBody"><p>I got this idea for what I’ll describe as a “net of nodes”. The nodes would be anchored to points, and when a mouse moves across them, the nodes attempt to repel the mouse while staying as anchored as possible to their point. The result acts as a much better explanation of what I wanted though:</p><div style="position:relative;height:200px;width:100%;"> <svg id="edges" style="position:absolute;left:0;top:0;width:100%;height:100%;"></svg><div id="net" style="position:absolute;overflow:hidden;left:0;top:0;width:100%;height:100%;"></div></div><p>I wanted each node’s position to be a function of the mouse’s position. This aspect lead to a lovely and simple design when all was said and done. To start writing this function, I first needed to define the system I was trying to create. I’ll explain how I did this by focusing on the behavior of a single node.</p><p>There are three points of interest for a node: the node’s <em>anchor point</em> (where the node rests when the mouse is far away), the <em>node position</em>, and the <em>mouse position</em>. Here’s how I’ll draw them:</p><p><img src="/blog/assets/posts/repel-nodes-with-a-linear-transform/whiteboard_labels.png " alt="point labels for the system" style="width:400px;" /></p><p>The first relationship to enforce between these points is that the distance between the mouse and the node’s actual position should be constant (we’ll actually revise this slightly in a bit, but for now, we’ll say it’s constant). Here’s a visual:</p><p><img src="/blog/assets/posts/repel-nodes-with-a-linear-transform/whiteboard_equation_1.png " alt="distance enforcing equation" style="width:600px;" /></p><p>The second relationship to enforce is that the tangent of the angle between mouse and anchor should equal the tangent of the angle between anchor and node. This is more easily described as an equivalent ratio between the differences in heights and widths of the same pairs of points (a/b = c/d):</p><p><img src="/blog/assets/posts/repel-nodes-with-a-linear-transform/whiteboard_equation_2.png " alt="distance enforcing equation" style="width:400px;" /></p><p>Together, we have the linear system of equations (x and y are nodeX and nodeY):</p><p><img src="/blog/assets/posts/repel-nodes-with-a-linear-transform/equation_1.png " alt="distance enforcing equation" style="width:400px;" /></p><p><img src="/blog/assets/posts/repel-nodes-with-a-linear-transform/equation_2.png " alt="distance enforcing equation" style="width:300px;" /></p><p>I gave these equations to Mathematica and told it to solve for {x, y}. Here’s a snippet of the result:</p><p><img src="/blog/assets/posts/repel-nodes-with-a-linear-transform/mathematica_out_1.png " alt="huge mathematica output snippet" style="width:600px;" /></p><p>That’s looking fairly messy. There’s a simple observation we can make though, that will simplify this result greatly. Notice that if we assume that <code>anchorX</code> and <code>anchorY</code> are both 0, then the equations in our system become significantly less complex. As a result of this assumption, <code>mouseX</code>, <code>mouseY</code>, <code>x</code>, and <code>y</code> will have to be normalized accordingly. Here’s the revised equations with <code>anchorX, anchorY = (0, 0)</code>:</p><p><img src="/blog/assets/posts/repel-nodes-with-a-linear-transform/equation_1_normed.png " alt="equation 1 redone with normed anchor" style="width:400px;" /></p><p><img src="/blog/assets/posts/repel-nodes-with-a-linear-transform/equation_2_normed.png " alt="equation 2 redone with normed anchor" style="width:150px;" /></p><p>This is looking much better already. Solving for x and y in Mathematica yields a more manageable result as well. But before I show those Mathematica results, I’ll make one more alteration to the system of equations. Earlier, I mentioned that we’ll revisit this distance <code>d</code>. Now, I’d like to revise it so that the distance <code>d</code> reduces as the mouse gets closer to the anchor. This way, there will be a more convincing illusion that the node is fighting between the attracting force of the anchor and the repelling force of the mouse.</p><p>If we assert that (1) when the distance between the mouse and the anchor is d, then the distance between the mouse and the node should be d, and (2) when the distance between the mouse and the anchor is 0, then the distance between the mouse and the node should be d/2, then we end up with this revised equation 1:</p><p><img src="/blog/assets/posts/repel-nodes-with-a-linear-transform/equation_1_distance.png " alt="equation 1 redone with reducing distance" style="width:600px;" /></p><p>Plugging for the last time into Mathematica and solving for <code>x</code> and <code>y</code>, we get this output (I’ve highlighted the parts that will be important to us):</p><p><img src="/blog/assets/posts/repel-nodes-with-a-linear-transform/mathematica_final_output.png " alt="final mathematica output of our system of linear equations" style="width:800px;" /></p><p>Now we’re ready for some JavaScript!</p><p>Here’s a function called <code>oppose</code>, which takes the values of <code>mouseX</code>, <code>mouseY</code>, <code>anchorX</code>, and <code>anchorY</code>, and returns the node’s position as <code>x</code> and <code>y</code>. We can take care of the normalization in this function for now, but it may become apparent later that we should do that elsewhere to save computation. But for now:</p><figure class="highlight"><figcaption>javascript</figcaption><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">oppose</span><span class="p">(</span><span class="nx">anchorX</span><span class="p">,</span> <span class="nx">anchorY</span><span class="p">,</span> <span class="nx">mouseX</span><span class="p">,</span> <span class="nx">mouseY</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">mXN</span> <span class="o">=</span> <span class="nx">mouseX</span> <span class="o">-</span> <span class="nx">anchorX</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">mYN</span> <span class="o">=</span> <span class="nx">mouseY</span> <span class="o">-</span> <span class="nx">anchorY</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">mXN</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">offsetX</span> <span class="o">=</span> <span class="nx">mXN</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="nx">s</span><span class="o">*</span><span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">((</span><span class="nx">mXN</span><span class="o">*</span><span class="nx">mXN</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nx">mYN</span><span class="o">*</span><span class="nx">mYN</span><span class="o">+</span><span class="nx">mXN</span><span class="o">*</span><span class="nx">mXN</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">offsetX</span> <span class="o">=</span> <span class="nx">mXN</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="nx">s</span><span class="o">*</span><span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">((</span><span class="nx">mXN</span><span class="o">*</span><span class="nx">mXN</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nx">mYN</span><span class="o">*</span><span class="nx">mYN</span><span class="o">+</span><span class="nx">mXN</span><span class="o">*</span><span class="nx">mXN</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">offsetY</span> <span class="o">=</span> <span class="nx">mYN</span><span class="o">*</span><span class="nx">offsetX</span><span class="o">/</span><span class="nx">mXN</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nx">left</span><span class="o">:</span> <span class="nx">offsetX</span> <span class="o">+</span> <span class="nx">anchorX</span><span class="p">,</span> <span class="nx">top</span><span class="o">:</span> <span class="nx">offsetY</span> <span class="o">+</span> <span class="nx">anchorY</span> <span class="p">};</span>
<span class="p">}</span></code></pre></figure><p>From this point, there’s freedom to create and maintain the nodes however you’d like. In my implementation, each node is a small, circular <code>div</code>. When a node is created, I store its <code>anchorX</code> and <code>anchorY</code> in its data attributes as <code>x</code> an <code>y</code>. This makes it easy to get those values back later, when I have to get each node anyway to adjust its position. I adjust the position of a node whenever the mouse moves, like so</p><figure class="highlight"><figcaption>javascript</figcaption><pre><code class="language-javascript" data-lang="javascript"><span class="nx">$</span><span class="p">(</span><span class="s2">&quot;.node&quot;</span><span class="p">).</span><span class="nx">each</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">dist</span> <span class="o">=</span> <span class="nx">distance</span><span class="p">(</span><span class="nx">mouseX</span><span class="p">,</span> <span class="nx">mouseY</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">y</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">dist</span> <span class="o">&lt;</span> <span class="nx">d</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">newPoint</span> <span class="o">=</span> <span class="nx">oppose</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="nx">mouseX</span><span class="p">,</span> <span class="nx">mouseY</span><span class="p">);</span>
        <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">css</span><span class="p">(</span><span class="nx">newPoint</span><span class="p">);</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">)}</span></code></pre></figure><p>, where <code>d</code> is the same <code>d</code> from our mathematica equations.</p><p>The net is complete as far as the nodes are concerned. However, the edges are what complete the feel of the net.</p><p>To build the edges, I chose to draw SVG lines, using the anchor points of the nodes as the start and end points for the lines. I constructed them by iterating over each pair of nodes, drawing a line between them if the distance between them was less than <code>d</code>. Unfortunately, this runs in terrible O(n^2) time. Luckily, I won’t be drawing any nets big enough to notice. However, one could imagine an algorithm in O(nlog(n) + n) time, in which the nodes are sorted by x position, and then a pass of width <code>2d</code> is made from left to right, connecting all nodes contained in the pass.</p><p>When building the edges in my implementation, I stored the id’s of the svg elements in arrays, indexed by node connections. I kept two arrays: <code>edgesTo</code>, and <code>edgesFrom</code>. To illustrate what I mean, here’s how I would obtain a list of the id’s of all edges connected to node 3: <code>edgesTo[3].concat(edgesFrom[3])</code>.</p><p>With this representation, we can complete the net update pass by adding the following after the <code>oppose</code> logic from before:</p><figure class="highlight"><figcaption>javascript</figcaption><pre><code class="language-javascript" data-lang="javascript"><span class="p">...</span>
<span class="kd">var</span> <span class="nx">edgesFromNode</span> <span class="o">=</span> <span class="nx">edgesFrom</span><span class="p">[</span><span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">id</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">edgesFromNode</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">$</span><span class="p">(</span><span class="s2">&quot;#svg&quot;</span> <span class="o">+</span> <span class="nx">edgesFromNode</span><span class="p">[</span><span class="nx">i</span><span class="p">]).</span><span class="nx">attr</span><span class="p">({</span><span class="s2">&quot;x2&quot;</span><span class="o">:</span> <span class="nx">newPoint</span><span class="p">.</span><span class="nx">left</span> <span class="o">+</span> <span class="nx">Node</span><span class="p">.</span><span class="nx">radius</span><span class="p">,</span>
                                        <span class="s2">&quot;y2&quot;</span><span class="o">:</span> <span class="nx">newPoint</span><span class="p">.</span><span class="nx">top</span> <span class="o">+</span> <span class="nx">Node</span><span class="p">.</span><span class="nx">radius</span><span class="p">});</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">edgesToNode</span> <span class="o">=</span> <span class="nx">Net</span><span class="p">.</span><span class="nx">nodes</span><span class="p">[</span><span class="nx">Net</span><span class="p">.</span><span class="nx">nodeId</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">))].</span><span class="nx">edgesTo</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">edgesToNode</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">$</span><span class="p">(</span><span class="s2">&quot;#svg&quot;</span> <span class="o">+</span> <span class="nx">edgesToNode</span><span class="p">[</span><span class="nx">i</span><span class="p">]).</span><span class="nx">attr</span><span class="p">({</span><span class="s2">&quot;x1&quot;</span><span class="o">:</span> <span class="nx">newPoint</span><span class="p">.</span><span class="nx">left</span> <span class="o">+</span> <span class="nx">Node</span><span class="p">.</span><span class="nx">radius</span><span class="p">,</span>
                                    <span class="s2">&quot;y1&quot;</span><span class="o">:</span> <span class="nx">newPoint</span><span class="p">.</span><span class="nx">top</span> <span class="o">+</span> <span class="nx">Node</span><span class="p">.</span><span class="nx">radius</span><span class="p">});</span>
<span class="p">}</span></code></pre></figure><p>Assuming the classes, nodes, and edges have been set up correctly, this update function works properly. On Chrome 50, a net of 200 nodes loads in ~820 milliseconds. The update function runs, on average, in 8ms (125 frames per second). Fine for our purposes! ◼</p></div><div id="disqus_thread"></div><script> var disqus_config = function () { this.page.url = "http://steven.codes/blog/repel-nodes-with-a-linear-transform/"; this.page.identifier = "/repel-nodes-with-a-linear-transform/"; this.page.title = "Repel Nodes with a Linear Transform"; }; (function() { /* DON'T EDIT BELOW THIS LINE */ var d = document, s = d.createElement('script'); s.src = '//stevencodes.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript></article></div><footer class="site-footer"><div class="wrapper"><h3 class="footer-heading"><a href="/blog/">steven.codes</a></h3><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"> <!--<li>Steven Traversi</li>--><li><a href="mailto:straversi@berkeley.edu">straversi@berkeley.edu</a></li><li> <a href="https://github.com/straversi"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg> </span><span class="username">straversi</span></a></li><li><a href="https://github.com/straversi/straversi.github.io/issues">See something wrong?</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"> <!--<li> <a href="https://twitter.com/StevenTraversi"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg> </span><span class="username">StevenTraversi</span></a></li>--></ul></div><div class="footer-col footer-col-3"><p>I post here about some of the things I'm working on.</p></div></div></div></footer></div></body></html>
