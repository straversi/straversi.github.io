<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Constraint Satisfaction With Sudoku • steven.codes</title><meta name="description" content="AI: A Modern Approach"><link href="https://fonts.googleapis.com/css?family=Roboto+Mono:300,400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Bitter:400,700" rel="stylesheet"> <!--<link rel="stylesheet" href="/blog/css/main.css"> --><link rel="stylesheet" href="/blog/css/main.css?v=2.0"><link rel="canonical" href="http://steven.codes/blog/constraint-satisfaction-with-sudoku/"><link rel="alternate" type="application/rss+xml" title="steven.codes" href="http://steven.codes/blog/feed.xml"></head><body><div class="page-content"><header class="new-header"><div class="wrapper"> <a class="site-title" href="/blog/">steven.codes</a></div></header><div class="wrapper"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header class="post-header"><h1 class="post-title" itemprop="name headline">Constraint Satisfaction With Sudoku</h1><p class="post-meta"> <time datetime="2015-12-03T11:47:36-08:00" itemprop="datePublished">Dec 3, 2015</time> <!-- <br>Read in about 9 minutes --></p></header><div class="post-content" itemprop="articleBody"><h2 id="ai-a-modern-approach">AI: A Modern Approach</h2><p>This semester, I’ve had the pleasure of taking “Intro to Artificial Intelligence” with Stuart Russell and Pat Virtue. Russell authored the definitive <strong>Artificial Intelligence, A Modern Approach</strong>, used as a foundation for AI curricula across the world.</p><p>In the first section of the class we covered “search”, including “constraint satisfaction problems” (CSP). Constraint satisfaction is an efficient way to represent a problem as a set of variables and rules for those variables. For example, you could have two variables whose domains are integers in [0, 10] that share a “diff” constraint- in other words, they may not be assigned the same number. A solution to a CSP happens when all variables been assigned a value and no constraints are violated.</p><p>The textbook <strong>AIAMA</strong> defines a search algorithm for solving CSPs that uses “backtracking” (which is really just a fancy term for how common search strategies like DFS work inherently). Essentially, if the search finds itself at a dead end, it will back up and traverse a different branch. In the case of CSPs, a dead end is an assignment from which no more values may be given to variables without constraint violation. If the backtracking algorithm finds itself here, it will un-assign some number of variables and continue the search. The algorithm is laid out below:</p><figure class="highlight"><figcaption>python</figcaption><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">assignment</span><span class="p">,</span> <span class="n">csp</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">assignment</span> <span class="ow">is</span> <span class="n">complete</span><span class="p">:</span> <span class="k">return</span> <span class="n">assignment</span>
  <span class="n">var</span> <span class="o">=</span> <span class="n">select</span><span class="o">-</span><span class="n">unassigned</span><span class="o">-</span><span class="n">variable</span><span class="p">(</span><span class="n">csp</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">each</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">order</span><span class="o">-</span><span class="n">domain</span><span class="o">-</span><span class="n">values</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">csp</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">consistent</span> <span class="k">with</span> <span class="n">assignment</span><span class="p">:</span>
      <span class="nb">set</span> <span class="n">var</span> <span class="o">=</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">assignment</span>
      <span class="n">inferences</span> <span class="o">=</span> <span class="n">inference</span><span class="p">(</span><span class="n">csp</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">inferences</span> <span class="n">do</span> <span class="ow">not</span> <span class="n">fail</span><span class="p">:</span>
        <span class="n">add</span> <span class="n">inferences</span> <span class="n">to</span> <span class="n">assignment</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">assignment</span><span class="p">,</span> <span class="n">csp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">failure</span><span class="p">:</span>
          <span class="k">return</span> <span class="n">result</span>
    <span class="n">remove</span> <span class="n">var</span> <span class="o">=</span> <span class="n">value</span> <span class="ow">and</span> <span class="n">inferences</span> <span class="kn">from</span> <span class="nn">assignment</span>
  <span class="k">return</span> <span class="n">failure</span></code></pre></figure><p>Some signatures to talk about:</p><p><em>select-unassigned-variable(csp)</em></p><p>At this point, we choose a variable to make an assignment for. We’re not actually assigning a value to anything yet. You may wonder, does the order that we choose variables for assignment matter? The answer is yes. Many problems find useful to always pick the variable that has the smallest remaining domain. This technique is called Minimum Remaining Values (MRV).</p><p><em>order-domain-values(var, assignment, csp)</em></p><p>The order in which we check the values in our chosen variable’s domain can make a difference as well. A common approach is to order values by how much they would affect neighboring domains. We’d like to choose the values that cause the LEAST amount of domain-constriction first. This is called Least Constraining Value (LCV).</p><p><em>“is consistent with assignment”</em></p><p>This checks if the assigning the given value to the given variable would violate any constraints. Therefore, it only involves checking the domains of variables that are constrained to the given one.</p><p><em>inference(csp, var, value)</em></p><p>When we give a variable a value, we have to prune the domains of all variables constrained with it. Sometimes, pruning a domain causes a variable to only have one value left in its domain. We could then make an assignment there, after which we could recursively begin another inference.</p><h2 id="sudoku-as-a-csp">Sudoku as a CSP</h2><p>I represent the various tiles of the sudoku board as A1 … I9, similarly to chess. The only constraints we need in sudoku are binary differences. E.g., “G4” != “G5”. What are the differences we need to enforce in sudoku? Each variable has 20 constraints: 8 in its row, 8 in its column, and 8 in its region; of these 24 constraints, 4 appear twice. I chose to store each variable’s constraints in a dictionary called <code>csp</code>, mapping {variable =&gt; set(variable)}. Lookup is easy: <code>csp["G4"]</code> returns a set of variables constrained to “G4”.</p><p>How should we represent the variables and assignments? I tried two methods. In the first representation I attempted, the assignments of variables to values were kept in a dictionary, mapped as VARIABLE -&gt; VALUE. In the second representation I tried, I represented the assignments as a dictionary mapping VARIABLE -&gt; DOMAIN. I tried this out because I realized that with the first representation, the domain of each variable was being recalculated many times. The results of the switch caused a huge decrease in time taken to solve: from ~850 seconds for ~2,000 puzzles to ~35 seconds.</p><p>For representing the domains of the variables with the second approach, I decided to use strings of values (because the values are strictly 1-9). So as we doing inferencing after making an assignment, some domains will have numbers in them replaced with nothing, e.g. “124589” | replace(“4”,””). This means that “4” is no longer a part of this domain.</p><h2 id="implementation">Implementation</h2><p>Right away, we can write two methods: <em>solved</em> and <em>consistent</em>. We can say that an assignment is <em>solved</em> if the length of every variable’s domain is 1. An value for a variable is <em>consistent</em> with an assignment if no other variables are already assigned that value, i.e. if the none of the domains of the constrained variables are equal to the new value. Here are implementations:</p><figure class="highlight"><figcaption>python3</figcaption><pre><code class="language-python3" data-lang="python3"><span class="k">def</span> <span class="nf">solved</span><span class="p">(</span><span class="n">assignment</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return TRUE if 1 assignment per tile. &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">assignment</span><span class="o">.</span><span class="n">values</span><span class="p">())</span></code></pre></figure><figure class="highlight"><figcaption>python3</figcaption><pre><code class="language-python3" data-lang="python3"><span class="k">def</span> <span class="nf">consistent</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">csp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return TRUE if no domain of variables constrained to VARIABLE equals VALUE. &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">assignment</span><span class="p">[</span><span class="n">constraint</span><span class="p">]</span> <span class="o">!=</span> <span class="n">value</span> <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">csp</span><span class="p">[</span><span class="n">variable</span><span class="p">])</span></code></pre></figure><p>Moving on to <em>select-unassigned-variable(csp)</em>, we simply find a variable with the smallest domain length, since each domain is just a string of values. We have to be careful not to select variables with domain lengths == 1, because this means that the variable is already assigned. Here are two implementations:</p><figure class="highlight"><figcaption>python3</figcaption><pre><code class="language-python3" data-lang="python3"><span class="k">def</span> <span class="nf">unassigned</span><span class="p">(</span><span class="n">assignment</span><span class="p">,</span> <span class="n">csp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return an unassigned variable from CSP. Minimum Remaining Values. &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">([</span><span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">assignment</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">assignment</span><span class="p">[</span><span class="n">var</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="n">assignment</span><span class="o">.</span><span class="n">get</span><span class="p">)</span></code></pre></figure><p>Interestingly, the above solution is much slower than the following one:</p><figure class="highlight"><figcaption>python3</figcaption><pre><code class="language-python3" data-lang="python3"><span class="k">def</span> <span class="nf">unassigned</span><span class="p">(</span><span class="n">assignment</span><span class="p">,</span> <span class="n">csp</span><span class="p">):</span>
    <span class="n">bestValue</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">bestVar</span> <span class="o">=</span> <span class="k">None</span>
    <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">assignment</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">bestValue</span><span class="p">:</span>
            <span class="n">bestValue</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">bestVar</span> <span class="o">=</span> <span class="n">var</span>
    <span class="k">return</span> <span class="n">bestVar</span></code></pre></figure><p>That’s ok with me, because the second version is more readable, I suppose.</p><p>For <em>order-domain-values(var, assignment, csp)</em>, I did some experimentation. I found that LCV causes a slower search than without it, for my implementation. And that’s okay: In <strong>AIAMA</strong>, it is mentioned that “least-constraining-value heuristic can be effective in some cases”. (p. 217) Apparently, not this case, with this implementation. Therefore, I simply returned the domain of the input variable with no processing with regards to order.</p><p>This leaves <em>inference(csp, var, value)</em>, where the fun happens. If a variable/value pair makes it to this step, then <em>inference</em>’s job is to make the assignment, then prune the domains of all constrained variables. If any variable’s domain is pruned to length 0, then the assignment has failed. If any variable’s domain is pruned to length 1, we should treat this as an assignment and call inference for that variable and value as well. Here’s my implementation:</p><figure class="highlight"><figcaption>python3</figcaption><pre><code class="language-python3" data-lang="python3"><span class="k">def</span> <span class="nf">inference</span><span class="p">(</span><span class="n">assignment</span><span class="p">,</span> <span class="n">var_to_update</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">csp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Assign VALUE to VAR_TO_UPDATE in ASSIGNMENT. Update domains of</span>
<span class="sd">       constrained variables from CSP. If any domains are reduced to 1, also</span>
<span class="sd">       inference from them. If any domains are reduced to 0, return False.</span>
<span class="sd">       Recursive forward checking.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">assignment</span><span class="p">[</span><span class="n">var_to_update</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">csp</span><span class="p">[</span><span class="n">var_to_update</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">assignment</span><span class="p">[</span><span class="n">constraint</span><span class="p">]:</span>
            <span class="k">continue</span>
        <span class="n">assignment</span><span class="p">[</span><span class="n">constraint</span><span class="p">]</span> <span class="o">=</span> <span class="n">assignment</span><span class="p">[</span><span class="n">constraint</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
        <span class="n">remaining</span> <span class="o">=</span> <span class="n">assignment</span><span class="p">[</span><span class="n">constraint</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">remaining</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">inference</span><span class="p">(</span><span class="n">assignment</span><span class="p">,</span> <span class="n">constraint</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">csp</span><span class="p">):</span>
                <span class="k">return</span> <span class="k">False</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">remaining</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">False</span>
    <span class="k">return</span> <span class="k">True</span></code></pre></figure><p>The only thing left to do when setting up your main() is run an initial inference pass when the puzzle is first loaded.</p><h2 id="results">Results</h2><p>I wrote my version of the solver so that it could take puzzles from this large set I found here: <a href="http://magictour.free.fr/top2365">2365 hard sudoku puzzles</a>. On average, my solver takes ~35 seconds to solve this set, with the median time to solve a puzzle being 0.005 seconds. The 35 seconds is dominated by a select few puzzles that take several seconds to solve. ◼</p></div><div id="disqus_thread"></div><script> var disqus_config = function () { this.page.url = "http://steven.codes/blog/constraint-satisfaction-with-sudoku/"; this.page.identifier = "/constraint-satisfaction-with-sudoku/"; this.page.title = "Constraint Satisfaction With Sudoku"; }; (function() { /* DON'T EDIT BELOW THIS LINE */ var d = document, s = d.createElement('script'); s.src = '//stevencodes.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript></article></div><footer class="site-footer"><div class="wrapper"><h3 class="footer-heading"><a href="/blog/">steven.codes</a></h3><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"> <!--<li>Steven Traversi</li>--><li><a href="mailto:straversi@berkeley.edu">straversi@berkeley.edu</a></li><li> <a href="https://github.com/straversi"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg> </span><span class="username">straversi</span></a></li><li><a href="https://github.com/straversi/straversi.github.io/issues">See something wrong?</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"> <!--<li> <a href="https://twitter.com/StevenTraversi"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg> </span><span class="username">StevenTraversi</span></a></li>--></ul></div><div class="footer-col footer-col-3"><p>I post here about some of the things I'm working on.</p></div></div></div></footer></div></body></html>
