<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Cloth Simulation • steven.codes</title><meta name="description" content="Overview"><link href="https://fonts.googleapis.com/css?family=Roboto+Mono:300,400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Bitter:400,700" rel="stylesheet"> <!--<link rel="stylesheet" href="/blog/css/main.css"> --><link rel="stylesheet" href="/blog/css/main.css?v=2.0"><link rel="canonical" href="http://steven.codes/blog/cloth-simulation/"><link rel="alternate" type="application/rss+xml" title="steven.codes" href="http://steven.codes/blog/feed.xml"><link rel="stylesheet" href="/blog/assets/posts/cloth-simulation/cloth_css.css " media="screen" type="text/css"></head><body><div class="page-content"><header class="new-header"><div class="wrapper"> <a class="site-title" href="/blog/">steven.codes</a></div></header><div class="wrapper"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header class="post-header"><h1 class="post-title" itemprop="name headline">Cloth Simulation</h1><p class="post-meta"> <time datetime="2017-05-18T02:47:36-07:00" itemprop="datePublished">May 18, 2017</time> <!-- <br>Read in about 14 minutes --></p></header><div class="post-content" itemprop="articleBody"><h2 id="overview">Overview</h2><p>How would you approach making a realistic animation of a waving flag? Would you study a video of a real flag and draw each frame? That would take a long time. Would you develop a mathematical model that describes how flag surfaces move? It may be difficult to bridge the last gap between that ‘fake’ look and realism.</p><p>A good way to approach it is to describe the cloth’s physical properties, the world, and physics the best we can, and “press play”. That is to say, create a simulation of the flag. The problem is open ended: How do we model the cloth? What information about the environment is important? I explored these ideas while creating a cloth simulation.</p><h2 id="masses-and-springs">Masses and Springs</h2><p>A good model for a cloth is a bunch of small masses and springs. A square cloth is broken up into a grid of points, instead of some continuous representation. This way, we can apply forces to a finite number of objects. Further, this makes modeling a cloth’s elastic properties easier. We can connect the point mass objects with a system of tiny springs that keep the cloth from contorting in an unnatural way. Springs act as a constraint on distance: applying a force to push away objects that are too close, or applying tension between objects that are too far.</p><p>I incorporated three types of springs into the cloth model: structural, shearing, and bending.</p><p><strong>Structural</strong> springs exist between each mass in a row and column fashion. They make sure the overall topology of the cloth remains consistent. They also prevent neighboring masses from being pulled apart or pushed together.</p><div><figure class="third"> <img src="/blog/assets/posts/cloth-simulation/1_figure_structural.jpg " /><figcaption>Just structural constraints.</figcaption></figure></div><p><strong>Shearing</strong> springs reach between diagonal masses. These prevent the entire grid from collapsing to one side, like parallelogram collapsing onto its side.</p><div><figure class="half align-bot"> <img src="/blog/assets/posts/cloth-simulation/1_figure_shearing_square.jpg " /><figcaption>Without diagonal distance constraints or angle constraints, a square can collapse sideways.</figcaption></figure><figure class="half align-bot"> <img src="/blog/assets/posts/cloth-simulation/1_figure_shearing.jpg " /><figcaption>Adding shearing springs that connect masses diagonally prevents this.</figcaption></figure></div><p>Lastly, <strong>bending</strong> springs span two masses, and prevent the cloth from creasing perfectly in half like an infinitely thin piece of paper, which would be unrealistic. In the following image, the effect of bending constraints can be seen.</p><div><figure class="half"> <img src="/blog/assets/posts/cloth-simulation/1_figure_bending.jpg " /><figcaption>Cloth is hanging over a surface, viewed from the side. <b>a</b> is under high compression. <b>b</b> is under moderate compression. <b>c</b> is under low compression.</figcaption></figure></div><p>The following image shows the springs as white lines in an example cloth. A shaded version of this cloth will be used in the simulations.</p><div><figure align="middle"> <img src="/blog/assets/posts/cloth-simulation/1_cloth.png " /><figcaption>View of a cloth in the simulator with all springs.</figcaption></figure></div><h2 id="simulation-via-numerical-integration">Simulation via numerical integration</h2><p>I implemented verlet integration to simulate the cloth. Verlet integration is a method of updating the point mass positions based on the forces acting on them at the given instant. It scales with the speed of the simulation, and can be damped. At each step of the simulation, verlet integration looks at every point mass in the system, aggregates the forces that are acting on it and moves the point mass to a new position based on these forces. In this case, the important forces are due to gravity and springs.</p><h3>Default parameters</h3><p>Here is what a <em>4 corners pinned</em> cloth looks like with the default parameters. You can reset the simulation by pressing the "reset" button.</p><p><button class="reset" id="default">reset</button></p><div><figure class="full"> <video class="default" autoplay=""> <source src="/blog/assets/posts/cloth-simulation/2_default_large.webm " type="video/webm" /> Please use or update Chrome to view the webm. </video><figcaption></figcaption></figure></div><h3>Varying spring constant</h3><p>A spring’s strength is determined by its <em>spring constant</em>, denoted as <em>ks</em>. This number determines how strongly the strings pull on the masses in the cloth. Below, I simulate two cloths: one with a low ks, and one with a high ks. The normal ks is 5000.</p><p><button class="reset" id="ks">reset both</button></p><div><figure class="half"> <video class="ks" autoplay=""> <source src="/blog/assets/posts/cloth-simulation/2_ks1000.webm " type="video/webm" /> Please use or update Chrome to view the webm. </video><figcaption>ks = 1000</figcaption></figure><figure class="half"> <video class="ks" autoplay=""> <source src="/blog/assets/posts/cloth-simulation/2_ks25000.webm " type="video/webm" /> Please use or update Chrome to view the webm. </video><figcaption>ks = 25000</figcaption></figure></div><p>In the low ks simulation (on the left), the cloth dips much further down than the high ks simulation (on the right). Before it comes to rest, waves in the cloth are also much more pronounced in the low ks simulation. The high ks simulation comes to rest before the low ks simulation.</p><h3>Varying density</h3><p>The <em>density</em> of the cloth changes the mass of each point that the cloth is comprised of. Changing the density of the cloth changes the degree to which it is affected by forces. Below, I simulate low and high density cloths. The default density is 15.</p><p><button class="reset" id="density">reset both</button></p><div><figure class="half"> <video class="density" autoplay=""> <source src="/blog/assets/posts/cloth-simulation/2_density3.webm " type="video/webm" /> Please use or update Chrome to view the webm. </video><figcaption>density = 3</figcaption></figure><figure class="half"> <video class="density" autoplay=""> <source src="/blog/assets/posts/cloth-simulation/2_density75.webm " type="video/webm" /> Please use or update Chrome to view the webm. </video><figcaption>density = 75</figcaption></figure></div><p>One thing to quickly notice is that the high density cloth behaves like the low ks cloth, and the low density cloth behaves like the high ks cloth. The only difference separating the changes in ks and density is that changes in ks affects the spring force contribution, while changes in density affect both spring and environmental force contributions.</p><h3>Varying damping</h3><p><em>Damping</em> controls how quickly our simulation loses energy. It is implemented in the verlet integration step of the simulation. Below, we simulate a cloth with low damping and high damping. The default damping value is 0.2.</p><p><button class="reset" id="damping">reset both</button></p><div><figure class="half"> <video class="damping" autoplay=""> <source src="/blog/assets/posts/cloth-simulation/2_damping0.4.webm " type="video/webm" /> Please use or update Chrome to view the webm. </video><figcaption>damping = 0.4</figcaption></figure><figure class="half"> <video class="damping" autoplay=""> <source src="/blog/assets/posts/cloth-simulation/2_damping1.0.webm " type="video/webm" /> Please use or update Chrome to view the webm. </video><figcaption>damping = 1.0</figcaption></figure></div><p>The low damping simulation takes a very long time to come to rest. Small changes ripple throughout the length of the cloth well after their inception. In the over-damped simulation, the opposite occurs: the cloth smoothly falls into a resting position, with virtually no waves propagating. Notice, however, that the over-damped simulation does not come to rest in the exactly the same way as the default simulation! (scroll back up to see the default simulation).</p><h2>3: Handling collisions with other objects</h2><p>To create a collision with a sphere, the following steps are taken:<ol><li>If a point mass is inside a sphere object:</li><li>Bump it away from the sphere's origin to the surface.</li><li>Correct its distance from its last position by a little bit, influenced by some <em>friction</em> value of the sphere.</li></ol>This algorithm allows the cloth to avoid being inside of another object. I implemented the algorithm and simulated a cloth falling over a sphere, varied across <em>ks</em> values.</p><h3>Collision with a sphere</h3><div><figure class="third"> <img src="/blog/assets/posts/cloth-simulation/3_ks500.png " /><figcaption>ks = 500</figcaption></figure><figure class="third"> <img src="/blog/assets/posts/cloth-simulation/3_ks5000.png " /><figcaption>ks = 5000</figcaption></figure><figure class="third"> <img src="/blog/assets/posts/cloth-simulation/3_ks50000.png " /><figcaption>ks = 50000</figcaption></figure></div><p>The first cloth looks like a very fine material, such as silk. The last cloth looks like a stiff material, such as felt. This is due to the varied spring constant values. For example, the material on the right (felt-like) has a high spring constant, so the cloth is more resistant to shearing and bending.</p><h3>Collision with a plane</h3><p>A similar process is implemented to detect collisions with planes. The test to see whether a collision occurs involves testing whether a point mass moves to the other side of a plane on a given simulation step. Below is the result of a cloth falling onto a plane and colliding with it.</p><div><figure class="half"> <img src="/blog/assets/posts/cloth-simulation/3_plane.png " /><figcaption>This cloth has landed on a plane.</figcaption></figure></div><h2>4: Handling self-collisions</h2><p>To handle self-collisions, point masses in the cloth need to be tested against each other to see if their positions are smaller than double the thickness of the cloth. The naive solution would test every point against every other point, and this would be O(n^2). We can do better.</p><p>To get better than quadratic in the number of point masses, we can test point masses only against their spatial neighbors. To do this, we first place all point masses into buckets based on their location in 3D space. This is called <em>Spatial Hashing</em>. We treat 3D space as a grid of boxes and iterate over every point mass, determining which box each of them lies in. Then, we go through all boxes, and test the all of the points in each against each other. This way, we only test a point against those in the same box, instead of against ALL other points. This saves a lot of time, and for a typical cloth simulation, will be O(n).</p><p>Spatial hashing involves the ability to uniquely identify each box that we've divided the 3D space with. The way I chose to do this is as follows:<ol><li>Figure out the coordinates of the position in question in the new "box-space".</li><li>Multiple each component of the new basis position by a large prime and XOR them together.</li></ol>This is a simple but somewhat common hashing scheme.<p>Below, I've simulated a vertical falling cloth that collides with itself.</p><button class="reset" id="4_default_w">reset</button><div><figure class="half"> <video class="4_default_w" autoplay=""> <source src="/blog/assets/posts/cloth-simulation/4_default_w.webm " type="video/webm" /> Please use or update Chrome to view the webm. </video><figcaption></figcaption></figure></div><p>As we can see, the cloth folds over itself instead of moving through itself. There are only a couple of frames in which the cloth intersects with itself, and these situations are infrequent. The reason this happens is because of the spatial hashing scheme: Imagine two points that are very close to each other, but fall into separate 3D boxes because their positions are near those boxes' borders. They would not get tested against each other for closeness! I revisit this problem later in part 5.</p><h3>Varying density</h3><p>Below, I vary the density of the cloth, then simulate the self-collision situation.</p><button class="reset" id="4_density">reset both</button><div><figure class="half"> <video class="4_density" autoplay=""> <source src="/blog/assets/posts/cloth-simulation/4_density3.webm " type="video/webm" /> Please use or update Chrome to view the webm. </video><figcaption>density = 3</figcaption></figure><figure class="half"> <video class="4_density" autoplay=""> <source src="/blog/assets/posts/cloth-simulation/4_density75.webm " type="video/webm" /> Please use or update Chrome to view the webm. </video><figcaption>density = 75</figcaption></figure></div><p>With low density, the spring forces keep the cloth very rigid, and it folds neatly. With high density, the cloth folds messily as the point masses quickly succumb to an increased ratio of environmental to spring forces.</p><h3>Varying spring constant ks</h3><p>Below, I vary the spring constant ks, then simulate the self-collision situation again.</p><button class="reset" id="4_ks">reset both</button><div><figure class="half"> <video class="4_ks" autoplay=""> <source src="/blog/assets/posts/cloth-simulation/4_ks1000.webm " type="video/webm" /> Please use or update Chrome to view the webm. </video><figcaption>ks = 1000</figcaption></figure><figure class="half"> <video class="4_ks" autoplay=""> <source src="/blog/assets/posts/cloth-simulation/4_ks25000.webm " type="video/webm" /> Please use or update Chrome to view the webm. </video><figcaption>ks = 25000</figcaption></figure></div><p>Similarly to the <em>4 corners pinned</em> cloth earlier, it is apparent that density and ks have something of an inverse relationship in how they affect the cloth. This time, the low spring constant allows the cloth on the left to fold over on itself more easily, while the high spring constant in the cloth on the right keeps it more rigid and structured.</p><h2>5.1: Wind</h2><p>Wind is a spatially varying environmental force. I had fun imagining the components of an overall force due to wind. I also got to have fun using the vector field functionality of <em>Grapher</em>, an OSX utility, to help me visualize my wind construction.</p><p>I imagined that wind not only varies through space, but also time. To implement this properly, I kept track of the total amount of time since the simulation began. I used this to parameterize my wind force.</p><p>I built the wind up in three steps:<ol><li>Varying the force over the z axis w/ respect to time</li><li>Varying the force over the y axis w/ respect to time</li><li>Adding a slight oscillating perturbation in the x axis w/ respect to time</li></ol></p><p>Below, I show the vector fields animated over time as I add each component above.</p><div><figure class="half"> <video autoplay="" loop=""> <source src="/blog/assets/posts/cloth-simulation/5_wind_z1_better.webm " type="video/webm" /> Please use or update Chrome to view the webm. </video><figcaption>Add &#916; z = 1.5 * abs(sin(z + t * 5))</figcaption></figure><figure class="half"> <video autoplay="" loop=""> <source src="/blog/assets/posts/cloth-simulation/5_wind_z2_better.webm " type="video/webm" /> Please use or update Chrome to view the webm. </video><figcaption>Modify to &#916; z = 1.5 * abs(sin(z + t * 5) + cos(y + t * 5) / 3)</figcaption></figure><figure class="half"> <video autoplay="" loop=""> <source src="/blog/assets/posts/cloth-simulation/5_wind_total_better.webm " type="video/webm" /> Please use or update Chrome to view the webm. </video><figcaption>Add &#916; x = 0.1 * sin(t * 5)</figcaption></figure><figure class="half"> <img src="/blog/assets/posts/cloth-simulation/high_wind_faster_compressed.gif " alt="cloth with wind" /><figcaption>The final product of applying the wind environmental force to a <em>2 corners pinned</em> cloth.</figcaption></figure></div><h2>5.2: Accurate self-collisions</h2><p>Remember the problem addressed at the end of section 4? In that two points may lie very close to one another but lie in separate 3D boxes? One way we can fix this is to not just search the bucket the point in question lies in while checking for closeness, but instead, check in <em>all the neighboring buckets</em>. This way, we sacrifice some speed for correctness. I'm not sure what this scheme is called, but I've nicknamed it <em>Uniform Spatial Hashing</em>.</p><p>To do this, I needed to improve the hashing scheme for a box, because I needed a way to retrieve neighbor boxes once they've been hashed. To solve this, I moved from using doubles to identify boxes to using 3D tuples to identify boxes. I had to write a 3D tuple-compatible unordered map in order to do this, but luckily I was able to reuse the idea behind hashing scheme I wrote for the doubles, with XOR.</p><p>Now that a box's neighbors were identifiable, I just made sure I included all of the neighboring boxes in the search space when checking for closeness of point masses.</p><p>Below, I simulate self-collision examples before and after the accuracy-boosting spatial hashing system.</p><button class="reset" id="5_collision">reset both</button><div><figure class="half"> <video class="5_collision" autoplay=""> <source src="/blog/assets/posts/cloth-simulation/4_default.webm " type="video/webm" /> Please use or update Chrome to view the webm. </video><figcaption>Regular spatial hashing</figcaption></figure><figure class="half"> <video id="speedup-1" class="5_collision" autoplay=""> <source src="/blog/assets/posts/cloth-simulation/5_uniform_spatial_hashing.webm " type="video/webm" /> Please use or update Chrome to view the webm. </video><figcaption>Improved "uniform" spatial hashing</figcaption></figure></div><p>Did you catch the improvement? I've captured a screengrab of the cloth in similar positions in each simulation so you can see the difference. The results are below:</p><div><figure class="half"> <img src="/blog/assets/posts/cloth-simulation/5_ush_no.png " alt="errors without uniform spatial hashing" /><figcaption>Regular spatial hashing still allows self-intersections very occasionally, due to its imperfect accuracy.</figcaption></figure><figure class="half"> <img src="/blog/assets/posts/cloth-simulation/5_ush_yes.png " alt="no errors with uniform spatial hashing" /><figcaption>My improved "Uniform" spatial hashing does not allow such situations.</figcaption></figure></div><p>That's it for my experiments with cloth simulation. Thanks for reading! &#9724;</p><!-- script to restart videos --> <script> var buttons = document.getElementsByClassName("reset"); for (var i = 0; i < buttons.length; i++) { buttons[i].onclick = function() { var videos = document.getElementsByClassName(this.id); for (var j = 0; j < videos.length; j++) { videos[j].currentTime = 0; videos[j].play(); } } } var s1 = document.getElementById("speedup-1"); s1.playbackRate = 3.3; </script></p></div><div id="disqus_thread"></div><script> var disqus_config = function () { this.page.url = "http://steven.codes/blog/cloth-simulation/"; this.page.identifier = "/cloth-simulation/"; this.page.title = "Cloth Simulation"; }; (function() { /* DON'T EDIT BELOW THIS LINE */ var d = document, s = d.createElement('script'); s.src = '//stevencodes.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript></article></div><footer class="site-footer"><div class="wrapper"><h3 class="footer-heading"><a href="/blog/">steven.codes</a></h3><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"> <!--<li>Steven Traversi</li>--><li><a href="mailto:straversi@berkeley.edu">straversi@berkeley.edu</a></li><li> <a href="https://github.com/straversi"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg> </span><span class="username">straversi</span></a></li><li><a href="https://github.com/straversi/straversi.github.io/issues">See something wrong?</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"> <!--<li> <a href="https://twitter.com/StevenTraversi"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg> </span><span class="username">StevenTraversi</span></a></li>--></ul></div><div class="footer-col footer-col-3"><p>I post here about some of the things I'm working on.</p></div></div></div></footer></div></body></html>
